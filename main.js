/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NavigableFileTreePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// FileTreeView.ts
var import_obsidian = require("obsidian");
var FileTreeView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.state = {
      currentPath: "/",
      collapsedFolders: /* @__PURE__ */ new Set(),
      selectedItems: /* @__PURE__ */ new Set(),
      lastSelectedItem: null,
      sortOrder: "asc",
      sortBy: "name"
    };
    this.handleFileClick = async (file, e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        this.toggleFileSelection(file);
      } else if (e.shiftKey && this.state.lastSelectedItem) {
        this.selectFileRange(file);
      } else {
        await this.openFile(file);
      }
    };
  }
  getViewType() {
    return "navigable-file-tree";
  }
  getDisplayText() {
    return "Navigable File Tree";
  }
  getIcon() {
    return "folder";
  }
  async onOpen() {
    this.initializeEventListeners();
    this.refreshView();
  }
  initializeEventListeners() {
    this.registerEvent(this.app.vault.on("create", () => {
      this.refreshView();
    }));
    this.registerEvent(this.app.vault.on("delete", () => {
      this.refreshView();
    }));
    this.registerEvent(this.app.vault.on("rename", () => {
      this.refreshView();
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.updateActiveState();
    }));
  }
  refreshView() {
    const container = this.contentEl;
    if (!container)
      return;
    container.empty();
    this.renderView();
  }
  renderView() {
    const container = this.contentEl;
    this.renderNavigationBar(container);
    this.renderToolbar(container);
    this.renderFileTree(container);
  }
  renderNavigationBar(container) {
    const pinnedPaths = this.plugin.getPinnedPaths();
    if (pinnedPaths.length === 0) {
      return;
    }
    const navBar = container.createEl("div", { cls: "nav-bar" });
    const navItems = navBar.createEl("div", { cls: "nav-items" });
    pinnedPaths.forEach((path, index) => {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file) {
        this.createNavButton(navItems, {
          icon: file instanceof import_obsidian.TFile ? "document" : "folder",
          text: file.name,
          onClick: () => file instanceof import_obsidian.TFile ? this.openFile(file) : this.navigateTo(file.path),
          onContextMenu: (e) => this.showPinnedItemMenu(e, path),
          draggable: true,
          dragData: { type: "pinned-item", path, index }
        });
      }
    });
    this.setupPinnedItemsDragAndDrop(navItems);
  }
  setupPinnedItemsDragAndDrop(container) {
    let draggedItem = null;
    let dragIndicator = null;
    let lastDropTarget = null;
    const createDragIndicator = () => {
      if (dragIndicator)
        return dragIndicator;
      dragIndicator = container.createEl("div", { cls: "nav-drag-indicator" });
      return dragIndicator;
    };
    const removeDragIndicator = () => {
      dragIndicator == null ? void 0 : dragIndicator.remove();
      dragIndicator = null;
      lastDropTarget = null;
    };
    const updateDragIndicator = (target, e) => {
      const indicator = createDragIndicator();
      const rect = target.getBoundingClientRect();
      const isAfter = e.clientX > rect.left + rect.width / 2;
      if ((lastDropTarget == null ? void 0 : lastDropTarget.element) === target && (lastDropTarget == null ? void 0 : lastDropTarget.isAfter) === isAfter) {
        return isAfter;
      }
      lastDropTarget = { element: target, isAfter };
      indicator.style.height = "24px";
      indicator.style.top = `${rect.top - container.getBoundingClientRect().top}px`;
      if (isAfter) {
        indicator.style.left = `${rect.right - container.getBoundingClientRect().left}px`;
        indicator.classList.add("after");
        indicator.classList.remove("before");
      } else {
        indicator.style.left = `${rect.left - container.getBoundingClientRect().left}px`;
        indicator.classList.add("before");
        indicator.classList.remove("after");
      }
      return isAfter;
    };
    container.addEventListener("dragstart", (e) => {
      var _a;
      draggedItem = e.target;
      if (draggedItem == null ? void 0 : draggedItem.classList.contains("nav-item")) {
        draggedItem.classList.add("dragging");
        (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", draggedItem.getAttribute("data-path") || "");
      }
    });
    container.addEventListener("dragend", () => {
      if (draggedItem) {
        draggedItem.classList.remove("dragging");
        draggedItem = null;
      }
      removeDragIndicator();
    });
    container.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (!draggedItem)
        return;
      const target = e.target;
      const navItem = target.closest(".nav-item");
      if (navItem && navItem !== draggedItem) {
        updateDragIndicator(navItem, e);
      }
    });
    container.addEventListener("drop", (e) => {
      e.preventDefault();
      if (!draggedItem)
        return;
      const target = e.target;
      const navItem = target.closest(".nav-item");
      if (navItem && navItem !== draggedItem) {
        const pinnedPaths = this.plugin.getPinnedPaths();
        const fromPath = draggedItem.getAttribute("data-path");
        const toPath = navItem.getAttribute("data-path");
        if (fromPath && toPath) {
          const fromIndex = pinnedPaths.indexOf(fromPath);
          const toIndex = pinnedPaths.indexOf(toPath);
          if (fromIndex !== -1 && toIndex !== -1) {
            pinnedPaths.splice(fromIndex, 1);
            const isAfter = updateDragIndicator(navItem, e);
            const newIndex = isAfter ? toIndex + 1 : toIndex;
            pinnedPaths.splice(newIndex, 0, fromPath);
            this.plugin.savePinnedPaths(pinnedPaths);
            this.refreshView();
          }
        }
      }
      removeDragIndicator();
    });
    container.addEventListener("dragleave", (e) => {
      const target = e.target;
      if (!container.contains(target)) {
        removeDragIndicator();
      }
    });
  }
  createNavButton(container, options) {
    var _a;
    const btn = container.createEl("button", {
      cls: "nav-item",
      attr: {
        draggable: options.draggable,
        "data-path": ((_a = options.dragData) == null ? void 0 : _a.path) || ""
      }
    });
    const iconEl = btn.createEl("div", { cls: "nav-icon" });
    (0, import_obsidian.setIcon)(iconEl, options.icon);
    btn.createEl("span", { text: options.text });
    btn.onclick = options.onClick;
    if (options.onContextMenu) {
      btn.oncontextmenu = options.onContextMenu;
    }
    if (options.draggable && options.dragData) {
      this.setupDraggableItem(btn, options.dragData);
    }
    return btn;
  }
  setupDraggableItem(element, dragData) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
      element.classList.add("dragging");
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  async navigateTo(path) {
    const target = this.app.vault.getAbstractFileByPath(path);
    if (target instanceof import_obsidian.TFile) {
      const leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf)
        await leaf.openFile(target);
    } else {
      this.state.currentPath = path;
      this.refreshView();
    }
  }
  async openFile(file) {
    this.state.selectedItems.clear();
    const viewType = file.extension === "canvas" ? "canvas" : "markdown";
    const existingLeaf = this.app.workspace.getLeavesOfType(viewType).find((leaf) => {
      var _a;
      const view = leaf.view;
      if (view.getViewType() === viewType && view instanceof import_obsidian.FileView) {
        return ((_a = view.file) == null ? void 0 : _a.path) === file.path;
      }
      return false;
    });
    if (existingLeaf) {
      this.app.workspace.setActiveLeaf(existingLeaf, { focus: true });
    } else {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf) {
        if (!activeLeaf.view || activeLeaf.getViewState().type === "empty") {
          await activeLeaf.openFile(file);
        } else {
          const newLeaf = this.app.workspace.getLeaf("tab");
          await newLeaf.openFile(file);
        }
      } else {
        const newLeaf = this.app.workspace.getLeaf(true);
        await newLeaf.openFile(file);
      }
    }
    this.updateSelection();
  }
  toggleFileSelection(file) {
    const path = file.path;
    if (this.state.selectedItems.has(path)) {
      this.state.selectedItems.delete(path);
    } else {
      this.state.selectedItems.add(path);
    }
    this.state.lastSelectedItem = path;
    this.updateSelection();
  }
  selectFileRange(file) {
    const allFiles = this.getAllFiles();
    const currentIndex = allFiles.findIndex((f) => f.path === file.path);
    const lastIndex = allFiles.findIndex((f) => f.path === this.state.lastSelectedItem);
    const [start, end] = [Math.min(currentIndex, lastIndex), Math.max(currentIndex, lastIndex)];
    allFiles.slice(start, end + 1).forEach((f) => {
      this.state.selectedItems.add(f.path);
    });
    this.updateSelection();
  }
  updateSelection() {
    this.containerEl.querySelectorAll(".tree-item.file").forEach((el) => {
      const path = el.getAttribute("data-path");
      if (path) {
        el.classList.toggle("selected", this.state.selectedItems.has(path));
      }
    });
  }
  renderToolbar(container) {
    const toolbar = container.createEl("div", { cls: "tree-toolbar" });
    const searchContainer = toolbar.createEl("div", { cls: "tree-search" });
    const searchInput = searchContainer.createEl("input", {
      cls: "tree-search-input",
      attr: {
        type: "text",
        placeholder: "Search files..."
      }
    });
    searchInput.addEventListener("input", () => {
      this.filterFiles(searchInput.value);
    });
    this.createToolbarButton(toolbar, {
      icon: "chevron-down-square",
      tooltip: "Expand/Collapse All",
      onClick: () => this.toggleAllFolders()
    });
    this.createToolbarButton(toolbar, {
      icon: "plus-square",
      tooltip: "Create New",
      onClick: (e) => this.showCreateMenu(e)
    });
    this.createToolbarButton(toolbar, {
      icon: "list-ordered",
      tooltip: "Sort",
      onClick: (e) => this.showSortMenu(e)
    });
  }
  createToolbarButton(container, options) {
    const button = container.createEl("button", {
      cls: "tree-tool-button",
      attr: { "aria-label": options.tooltip }
    });
    const iconEl = button.createEl("div", { cls: "nav-icon" });
    (0, import_obsidian.setIcon)(iconEl, options.icon);
    button.onclick = options.onClick;
    return button;
  }
  toggleAllFolders() {
    const allFolders = Array.from(this.containerEl.querySelectorAll(".folder"));
    const hasCollapsed = allFolders.some((folder) => {
      const path = folder.getAttribute("data-path");
      return path && this.state.collapsedFolders.has(path);
    });
    if (hasCollapsed) {
      this.state.collapsedFolders.clear();
    } else {
      allFolders.forEach((folder) => {
        const path = folder.getAttribute("data-path");
        if (path)
          this.state.collapsedFolders.add(path);
      });
    }
    this.refreshView();
  }
  filterFiles(searchTerm) {
    const treeItems = this.containerEl.querySelectorAll(".tree-item");
    const searchText = searchTerm.toLowerCase().trim();
    if (!searchText) {
      treeItems.forEach((item) => {
        item.classList.remove("hidden");
        if (item.classList.contains("folder")) {
          const children = item.querySelector(".folder-children");
          if (children) {
            children.classList.toggle("collapsed", this.state.collapsedFolders.has(item.getAttribute("data-path") || ""));
          }
        }
      });
      return;
    }
    treeItems.forEach((item) => {
      var _a, _b, _c;
      let isMatch = false;
      if (item.classList.contains("file")) {
        const fileName = ((_a = item.querySelector(".file-name")) == null ? void 0 : _a.textContent) || "";
        const fileExt = ((_b = item.querySelector(".file-ext")) == null ? void 0 : _b.textContent) || "";
        const fullName = (fileName + fileExt).toLowerCase();
        isMatch = fullName.includes(searchText);
      } else if (item.classList.contains("folder")) {
        const folderName = (((_c = item.querySelector(".folder-title span")) == null ? void 0 : _c.textContent) || "").toLowerCase();
        isMatch = folderName.includes(searchText);
        const children = item.querySelector(".folder-children");
        if (children) {
          const hasMatchingChild = Array.from(children.querySelectorAll(".tree-item")).some((child) => {
            var _a2;
            const childName = (((_a2 = child.querySelector(".file-name, .folder-title span")) == null ? void 0 : _a2.textContent) || "").toLowerCase();
            return childName.includes(searchText);
          });
          if (hasMatchingChild) {
            isMatch = true;
            this.state.collapsedFolders.delete(item.getAttribute("data-path") || "");
            const collapseIcon = item.querySelector(".collapse-icon");
            if (collapseIcon) {
              collapseIcon.classList.remove("collapsed");
            }
            children.classList.remove("collapsed");
          }
        }
      }
      item.classList.toggle("hidden", !isMatch);
    });
  }
  showCreateMenu(e) {
    const menu = new import_obsidian.Menu();
    const currentFolder = this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!(currentFolder instanceof import_obsidian.TFolder))
      return;
    menu.addItem((item) => {
      item.setTitle("New Note").setIcon("document").onClick(() => this.createNewFile("md", currentFolder));
    });
    menu.addItem((item) => {
      item.setTitle("New Canvas").setIcon("layout-dashboard").onClick(() => this.createNewFile("canvas", currentFolder));
    });
    menu.addItem((item) => {
      item.setTitle("New Folder").setIcon("folder").onClick(() => this.createNewFolder(currentFolder));
    });
    menu.showAtMouseEvent(e);
  }
  showSortMenu(e) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle("Sort by Name").setIcon(this.state.sortBy === "name" ? "checkmark" : "").onClick(() => {
        this.state.sortBy = "name";
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Sort by Modified").setIcon(this.state.sortBy === "modified" ? "checkmark" : "").onClick(() => {
        this.state.sortBy = "modified";
        this.refreshView();
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Ascending").setIcon(this.state.sortOrder === "asc" ? "checkmark" : "").onClick(() => {
        this.state.sortOrder = "asc";
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Descending").setIcon(this.state.sortOrder === "desc" ? "checkmark" : "").onClick(() => {
        this.state.sortOrder = "desc";
        this.refreshView();
      });
    });
    menu.showAtMouseEvent(e);
  }
  showPinnedItemMenu(e, path) {
    const menu = new import_obsidian.Menu();
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      if (file instanceof import_obsidian.TFile) {
        menu.addItem((item) => {
          item.setTitle("Open in New Tab").setIcon("lucide-split").onClick(async () => {
            const leaf = this.app.workspace.splitActiveLeaf();
            await leaf.openFile(file);
          });
        });
      }
      menu.addItem((item) => {
        item.setTitle("Remove from Navigation").setIcon("trash").onClick(() => {
          this.plugin.removeFromPinnedPaths(path);
          this.refreshView();
        });
      });
    }
    menu.showAtMouseEvent(e);
  }
  async createNewFile(extension, targetFolder) {
    const parentFile = targetFolder || this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!parentFile || !(parentFile instanceof import_obsidian.TFolder))
      return;
    let baseName = "Untitled";
    let counter = 0;
    let fileName = baseName;
    let filePath = "";
    do {
      fileName = counter === 0 ? baseName : `${baseName} ${counter}`;
      filePath = `${parentFile.path}/${fileName}.${extension}`;
      counter++;
    } while (this.app.vault.getAbstractFileByPath(filePath));
    try {
      const content = extension === "canvas" ? '{"nodes":[],"edges":[]}' : "";
      const file = await this.app.vault.create(filePath, content);
      this.refreshView();
      const leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf) {
        await leaf.openFile(file);
      }
      setTimeout(() => {
        const fileEl = this.containerEl.querySelector(`[data-path="${file.path}"]`);
        if (fileEl) {
          this.startRename(file);
        }
      }, 50);
    } catch (error) {
      console.error(`Failed to create new ${extension} file:`, error);
      new import_obsidian.Notice(`Failed to create new ${extension} file: ${error.message}`);
    }
  }
  async createNewFolder(targetFolder) {
    const parentFile = targetFolder || this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!parentFile || !(parentFile instanceof import_obsidian.TFolder))
      return;
    let baseName = "New Folder";
    let counter = 0;
    let folderName = baseName;
    let folderPath = "";
    do {
      folderName = counter === 0 ? baseName : `${baseName} ${counter}`;
      folderPath = `${parentFile.path}/${folderName}`;
      counter++;
    } while (this.app.vault.getAbstractFileByPath(folderPath));
    try {
      const folder = await this.app.vault.createFolder(folderPath);
      this.refreshView();
      setTimeout(() => {
        const folderEl = this.containerEl.querySelector(`[data-path="${folder.path}"]`);
        if (folderEl) {
          this.startRename(folder);
        }
      }, 50);
    } catch (error) {
      console.error("Failed to create new folder:", error);
      new import_obsidian.Notice(`Failed to create new folder: ${error.message}`);
    }
  }
  getAllFiles() {
    const files = [];
    const processFolder = (folder) => {
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian.TFile) {
          files.push(child);
        } else if (child instanceof import_obsidian.TFolder) {
          processFolder(child);
        }
      });
    };
    processFolder(this.app.vault.getRoot());
    return files;
  }
  renderFileTree(container) {
    const treeContainer = container.createEl("div", { cls: "tree-container" });
    const vault = this.app.vault;
    const root = vault.getRoot();
    const targetFile = this.state.currentPath === "/" ? root : vault.getAbstractFileByPath(this.state.currentPath);
    if (targetFile instanceof import_obsidian.TFolder) {
      this.renderFolderContents(treeContainer, targetFile);
    }
  }
  renderFolderContents(container, folder) {
    const items = folder.children.sort((a, b) => this.sortItems(a, b));
    for (const item of items) {
      if (item instanceof import_obsidian.TFolder) {
        if (!this.shouldHideFolder(item)) {
          this.renderFolderItem(container, item);
        }
      } else if (item instanceof import_obsidian.TFile) {
        this.renderFileItem(container, item);
      }
    }
  }
  shouldHideFolder(folder) {
    return this.plugin.settings.hideAttachments && this.plugin.settings.attachmentFolders.includes(folder.name);
  }
  sortItems(a, b) {
    if (a instanceof import_obsidian.TFolder && !(b instanceof import_obsidian.TFolder))
      return -1;
    if (!(a instanceof import_obsidian.TFolder) && b instanceof import_obsidian.TFolder)
      return 1;
    let comparison = 0;
    if (this.state.sortBy === "name") {
      comparison = a.name.localeCompare(b.name);
    } else {
      const aTime = a instanceof import_obsidian.TFile ? a.stat.mtime : 0;
      const bTime = b instanceof import_obsidian.TFile ? b.stat.mtime : 0;
      comparison = aTime - bTime;
    }
    return this.state.sortOrder === "asc" ? comparison : -comparison;
  }
  renderFileItem(container, file) {
    var _a;
    const fileEl = container.createEl("div", {
      cls: `tree-item file ${((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) === file.path ? "active" : ""} ${this.state.selectedItems.has(file.path) ? "selected" : ""}`,
      attr: {
        "data-path": file.path,
        "draggable": "true"
      }
    });
    const fileTitle = fileEl.createEl("div", { cls: "file-title" });
    const fileIcon = fileTitle.createEl("span", { cls: "file-icon" });
    this.setFileIcon(fileIcon, file);
    fileTitle.createEl("span", {
      cls: "file-name",
      text: file.basename
    });
    fileTitle.createEl("span", {
      cls: "file-ext",
      text: "." + file.extension
    });
    fileTitle.onclick = (e) => this.handleFileClick(file, e);
    fileTitle.oncontextmenu = (e) => this.showFileContextMenu(e, file);
    this.setupDraggableFile(fileEl, file);
  }
  renderFolderItem(container, folder) {
    const folderEl = container.createEl("div", {
      cls: "tree-item folder",
      attr: {
        "data-path": folder.path,
        "draggable": "true"
      }
    });
    const folderHeader = folderEl.createEl("div", { cls: "folder-header" });
    const collapseIcon = folderHeader.createEl("div", {
      cls: `collapse-icon ${this.state.collapsedFolders.has(folder.path) ? "collapsed" : ""}`
    });
    (0, import_obsidian.setIcon)(collapseIcon, "chevron-down");
    const folderTitle = folderHeader.createEl("div", { cls: "folder-title" });
    const folderIcon = folderTitle.createEl("span", { cls: "folder-icon" });
    (0, import_obsidian.setIcon)(folderIcon, "folder");
    folderTitle.createEl("span", { text: folder.name });
    this.setupFolderDropZone(folderTitle, folder);
    this.setupDraggableFolder(folderEl, folder);
    collapseIcon.onclick = (e) => {
      e.stopPropagation();
      this.toggleFolder(folder);
    };
    folderTitle.onclick = (e) => {
      e.stopPropagation();
      this.toggleFolder(folder);
    };
    folderTitle.oncontextmenu = (e) => this.showFolderContextMenu(e, folder);
    if (!this.state.collapsedFolders.has(folder.path)) {
      const childrenContainer = folderEl.createEl("div", { cls: "folder-children" });
      this.setupDropZone(childrenContainer, folder);
      this.renderFolderContents(childrenContainer, folder);
    } else {
      const childrenContainer = folderEl.createEl("div", { cls: "folder-children collapsed" });
      this.setupDropZone(childrenContainer, folder);
    }
  }
  setupFolderDropZone(element, folder) {
    let dragEnterCount = 0;
    let dropTimeout;
    element.addEventListener("dragenter", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount++;
      if (dropTimeout) {
        clearTimeout(dropTimeout);
      }
      element.classList.add("drop-target");
    });
    element.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount--;
      if (dragEnterCount === 0) {
        dropTimeout = setTimeout(() => {
          element.classList.remove("drop-target");
        }, 50);
      }
    });
    element.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
    });
    element.addEventListener("drop", async (e) => {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount = 0;
      element.classList.remove("drop-target");
      try {
        const data = JSON.parse(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "");
        if (data.type === "file") {
          const paths = data.paths;
          for (const path of paths) {
            const file = this.app.vault.getAbstractFileByPath(path);
            if (file instanceof import_obsidian.TFile && file.parent !== folder) {
              const newPath = `${folder.path}/${file.name}`;
              await this.app.vault.rename(file, newPath);
            }
          }
        } else if (data.type === "folder") {
          const sourceFile = this.app.vault.getAbstractFileByPath(data.path);
          if (sourceFile instanceof import_obsidian.TFolder && sourceFile !== folder && !folder.path.startsWith(sourceFile.path)) {
            const newPath = `${folder.path}/${sourceFile.name}`;
            await this.app.vault.rename(sourceFile, newPath);
          }
        }
        this.refreshView();
      } catch (error) {
        console.error("Failed to process drop:", error);
        new import_obsidian.Notice("Failed to move item(s)");
      }
    });
  }
  setupDropZone(element, folder) {
    let dragEnterCount = 0;
    let dropTimeout;
    element.addEventListener("dragenter", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount++;
      if (dropTimeout) {
        clearTimeout(dropTimeout);
      }
      element.classList.add("drop-target");
    });
    element.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount--;
      if (dragEnterCount === 0) {
        dropTimeout = setTimeout(() => {
          element.classList.remove("drop-target");
        }, 50);
      }
    });
    element.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
    });
    element.addEventListener("drop", async (e) => {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      dragEnterCount = 0;
      element.classList.remove("drop-target");
      try {
        const data = JSON.parse(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "");
        if (data.type === "file") {
          const paths = data.paths;
          for (const path of paths) {
            const file = this.app.vault.getAbstractFileByPath(path);
            if (file instanceof import_obsidian.TFile && file.parent !== folder) {
              const newPath = `${folder.path}/${file.name}`;
              await this.app.vault.rename(file, newPath);
            }
          }
        } else if (data.type === "folder") {
          const sourceFile = this.app.vault.getAbstractFileByPath(data.path);
          if (sourceFile instanceof import_obsidian.TFolder && sourceFile !== folder && !folder.path.startsWith(sourceFile.path)) {
            const newPath = `${folder.path}/${sourceFile.name}`;
            await this.app.vault.rename(sourceFile, newPath);
          }
        }
        this.refreshView();
      } catch (error) {
        console.error("Failed to process drop:", error);
        new import_obsidian.Notice("Failed to move item(s)");
      }
    });
  }
  setupDraggableFile(element, file) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      e.stopPropagation();
      element.classList.add("dragging");
      const dragData = {
        type: "file",
        paths: this.state.selectedItems.has(file.path) ? Array.from(this.state.selectedItems) : [file.path]
      };
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  setupDraggableFolder(element, folder) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      e.stopPropagation();
      element.classList.add("dragging");
      const dragData = {
        type: "folder",
        path: folder.path
      };
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  toggleFolder(folder) {
    if (this.state.collapsedFolders.has(folder.path)) {
      this.state.collapsedFolders.delete(folder.path);
    } else {
      this.state.collapsedFolders.add(folder.path);
    }
    this.refreshView();
  }
  showFileContextMenu(e, file) {
    const menu = new import_obsidian.Menu();
    if (this.state.selectedItems.size > 1) {
      this.showMultipleSelectionMenu(menu);
    } else {
      this.showSingleFileMenu(menu, file);
    }
    menu.showAtMouseEvent(e);
  }
  showMultipleSelectionMenu(menu) {
    const selectedFiles = Array.from(this.state.selectedItems).map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian.TFile);
    menu.addItem((item) => {
      item.setTitle(`Delete ${selectedFiles.length} items`).setIcon("trash").onClick(async () => {
        for (const file of selectedFiles) {
          await this.app.fileManager.trashFile(file);
        }
        this.state.selectedItems.clear();
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Move to...").setIcon("folder").onClick(() => {
        const folderMenu = new import_obsidian.Menu();
        this.buildFolderSubmenu(folderMenu, this.app.vault.getRoot(), selectedFiles);
        folderMenu.showAtMouseEvent(new MouseEvent("click"));
      });
    });
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(() => {
        for (const file of selectedFiles) {
          this.plugin.addToPinnedPaths(file.path);
        }
        this.refreshView();
      });
    });
  }
  buildFolderSubmenu(menu, folder, files) {
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFolder && !this.shouldHideFolder(child)) {
        menu.addItem((item) => {
          item.setTitle(child.name);
          const hasSubfolders = child.children.some((c) => c instanceof import_obsidian.TFolder);
          if (hasSubfolders) {
            item.setIcon("chevron-right");
          }
          item.onClick((e) => {
            if (hasSubfolders && e instanceof MouseEvent) {
              const subMenu = new import_obsidian.Menu();
              this.buildFolderSubmenu(subMenu, child, files);
              subMenu.showAtPosition({
                x: e.clientX,
                y: e.clientY
              });
            } else {
              this.moveFilesToFolder(files, child);
            }
          });
        });
      }
    }
  }
  async moveFilesToFolder(files, targetFolder) {
    for (const file of files) {
      if (file.parent !== targetFolder) {
        const newPath = `${targetFolder.path}/${file.name}`;
        await this.app.vault.rename(file, newPath);
      }
    }
    this.state.selectedItems.clear();
    this.refreshView();
  }
  showSingleFileMenu(menu, file) {
    menu.addItem((item) => {
      item.setTitle("Open in New Tab").setIcon("lucide-split").onClick(async () => {
        const leaf = this.app.workspace.splitActiveLeaf();
        await leaf.openFile(file);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(async () => {
        await this.plugin.addToPinnedPaths(file.path);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Rename").setIcon("pencil").onClick(() => this.startRename(file));
    });
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(async () => {
        await this.app.fileManager.trashFile(file);
        this.refreshView();
      });
    });
  }
  showFolderContextMenu(e, folder) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle("New Note").setIcon("document").onClick(() => this.createNewFile("md", folder));
    });
    menu.addItem((item) => {
      item.setTitle("New Canvas").setIcon("layout-dashboard").onClick(() => this.createNewFile("canvas", folder));
    });
    menu.addItem((item) => {
      item.setTitle("New Folder").setIcon("folder").onClick(() => this.createNewFolder(folder));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(async () => {
        await this.plugin.addToPinnedPaths(folder.path);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Rename").setIcon("pencil").onClick(() => this.startRename(folder));
    });
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(async () => {
        await this.app.fileManager.trashFile(folder);
        this.refreshView();
      });
    });
    menu.showAtMouseEvent(e);
  }
  setFileIcon(element, file) {
    const extension = file.extension.toLowerCase();
    switch (extension) {
      case "md":
        (0, import_obsidian.setIcon)(element, "document");
        break;
      case "canvas":
        (0, import_obsidian.setIcon)(element, "layout-dashboard");
        break;
      default:
        (0, import_obsidian.setIcon)(element, "document");
        break;
    }
  }
  async startRename(item) {
    const itemEl = this.containerEl.querySelector(`[data-path="${item.path}"]`);
    if (!itemEl)
      return;
    const titleEl = itemEl.querySelector(".file-title, .folder-title");
    if (!titleEl || !(titleEl instanceof HTMLElement))
      return;
    const oldName = item.name;
    const baseName = item instanceof import_obsidian.TFile ? item.basename : oldName;
    titleEl.empty();
    const input = titleEl.createEl("input", {
      cls: "rename-input",
      attr: {
        value: baseName,
        type: "text"
      }
    });
    input.focus();
    input.select();
    const finishRename = async () => {
      var _a, _b;
      const newName = input.value.trim();
      if (newName && newName !== baseName) {
        const extension = item instanceof import_obsidian.TFile ? `.${item.extension}` : "";
        const newPath = `${(_b = (_a = item.parent) == null ? void 0 : _a.path) != null ? _b : ""}/${newName}${extension}`;
        try {
          await this.app.vault.rename(item, newPath);
          if (item instanceof import_obsidian.TFile) {
            const newFile = this.app.vault.getAbstractFileByPath(newPath);
            if (newFile instanceof import_obsidian.TFile) {
              const leaf = this.app.workspace.getMostRecentLeaf();
              if (leaf) {
                await leaf.openFile(newFile);
              }
            }
          }
        } catch (error) {
          console.error("Failed to rename:", error);
          new import_obsidian.Notice(`Failed to rename: ${error.message}`);
        }
      }
      this.refreshView();
    };
    input.onblur = finishRename;
    input.onkeydown = async (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        await finishRename();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.refreshView();
      }
    };
  }
  updateFileState(file) {
    const fileEl = this.containerEl.querySelector(`[data-path="${file.path}"]`);
    if (fileEl) {
      const titleEl = fileEl.querySelector(".file-title");
      if (titleEl) {
        const nameEl = titleEl.querySelector(".file-name");
        const extEl = titleEl.querySelector(".file-ext");
        if (nameEl && extEl) {
          nameEl.textContent = file.basename;
          extEl.textContent = "." + file.extension;
        }
      }
    }
  }
  updateActiveState() {
    const activeFile = this.app.workspace.getActiveFile();
    this.containerEl.querySelectorAll(".tree-item.file").forEach((el) => {
      const path = el.getAttribute("data-path");
      if (path) {
        el.classList.toggle("active", (activeFile == null ? void 0 : activeFile.path) === path);
      }
    });
  }
};

// settings.ts
var DEFAULT_SETTINGS = {
  hideAttachments: false,
  openOnStartup: false,
  attachmentFolders: [],
  showRootNav: true,
  pinnedPaths: []
};

// settings-tab.ts
var import_obsidian2 = require("obsidian");
var NavigableFileTreeSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Hide attachments folders").setDesc("Hide folders that typically contain attachments").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideAttachments).onChange(async (value) => {
      var _a;
      this.plugin.settings.hideAttachments = value;
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Open on startup").setDesc("Automatically open the file tree when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.openOnStartup).onChange(async (value) => {
      this.plugin.settings.openOnStartup = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian2.Setting(containerEl).setName("Attachment folders").setDesc('Folders to hide when "Hide attachments folders" is enabled (one per line)').addTextArea((text) => text.setValue(this.plugin.settings.attachmentFolders.join("\n")).onChange(async (value) => {
      var _a;
      this.plugin.settings.attachmentFolders = value.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Root navigation").setDesc("Show Root button in navigation bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRootNav).onChange(async (value) => {
      var _a;
      this.plugin.settings.showRootNav = value;
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
  }
};

// main.ts
var NavigableFileTreePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.pinnedPaths = [];
  }
  async onload() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.pinnedPaths = this.settings.pinnedPaths || [];
    this.registerView("navigable-file-tree", (leaf) => this.view = new FileTreeView(leaf, this));
    const ribbonIconEl = this.addRibbonIcon("list-tree", "Navigable File Tree", () => {
      this.activateView();
    });
    ribbonIconEl.draggable = true;
    ribbonIconEl.addEventListener("dragstart", (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.setData("text/plain", "navigable-file-tree");
        e.dataTransfer.effectAllowed = "move";
      }
    });
    this.addSettingTab(new NavigableFileTreeSettingTab(this.app, this));
    if (this.settings.openOnStartup) {
      this.activateView();
    }
  }
  async onunload() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType("navigable-file-tree");
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeftLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: "navigable-file-tree",
          active: true
        });
        this.app.workspace.revealLeaf(leaf);
      }
    } else {
      leaves.forEach((leaf) => leaf.detach());
    }
  }
  async addToPinnedPaths(path) {
    console.log("Adding path to pinned paths:", path);
    if (!this.pinnedPaths.includes(path)) {
      this.pinnedPaths.push(path);
      this.settings.pinnedPaths = this.pinnedPaths;
      await this.saveSettings();
      if (this.view) {
        console.log("Refreshing view with new pinned paths:", this.pinnedPaths);
        this.view.refreshView();
      }
    }
  }
  removeFromPinnedPaths(path) {
    var _a;
    this.pinnedPaths = this.pinnedPaths.filter((p) => p !== path);
    this.settings.pinnedPaths = this.pinnedPaths;
    this.saveSettings();
    (_a = this.view) == null ? void 0 : _a.refreshView();
  }
  getPinnedPaths() {
    return this.pinnedPaths;
  }
  savePinnedPaths(paths) {
    this.pinnedPaths = paths;
    this.settings.pinnedPaths = paths;
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
