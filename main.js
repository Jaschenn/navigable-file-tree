/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NavigableFileTreePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// FileTreeView.ts
var import_obsidian = require("obsidian");
var FileTreeView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.state = {
      currentPath: "/",
      collapsedFolders: /* @__PURE__ */ new Set(),
      selectedItems: /* @__PURE__ */ new Set(),
      lastSelectedItem: null,
      sortOrder: "asc",
      sortBy: "name"
    };
    this.handleFileClick = async (file, e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        this.toggleFileSelection(file);
      } else if (e.shiftKey && this.state.lastSelectedItem) {
        this.selectFileRange(file);
      } else {
        await this.openFile(file);
      }
    };
    this.initializeEventListeners();
  }
  initializeEventListeners() {
    this.registerEvent(this.app.vault.on("modify", () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        this.updateFileState(activeFile);
      }
    }));
    this.registerEvent(this.app.vault.on("rename", () => this.refreshView()));
    this.registerEvent(this.app.vault.on("delete", () => this.refreshView()));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.updateActiveState();
    }));
    this.registerDomEvent(document, "click", (e) => {
      if (!this.containerEl.contains(e.target)) {
        this.state.selectedItems.clear();
        this.updateSelection();
      }
    });
  }
  getViewType() {
    return "navigable-file-tree";
  }
  getDisplayText() {
    return "Navigable File Tree";
  }
  getIcon() {
    return "list-tree";
  }
  async onOpen() {
    this.renderView();
  }
  refreshView() {
    const container = this.containerEl.children[1];
    if (!container)
      return;
    const scrollTop = container.scrollTop;
    this.renderView();
    container.scrollTop = scrollTop;
  }
  renderView() {
    const container = this.containerEl.children[1];
    container.empty();
    this.renderNavigationBar(container);
    this.renderToolbar(container);
    this.renderFileTree(container);
  }
  renderNavigationBar(container) {
    const navBar = container.createEl("div", { cls: "nav-bar" });
    const navItems = navBar.createEl("div", { cls: "nav-items" });
    if (this.plugin.settings.showRootNav) {
      this.createNavButton(navItems, {
        icon: '<path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>',
        text: "Root",
        onClick: () => this.navigateTo("/"),
        draggable: false
      });
    }
    const pinnedPaths = this.plugin.getPinnedPaths();
    pinnedPaths.forEach((path, index) => {
      this.createNavButton(navItems, {
        icon: '<path fill="currentColor" d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>',
        text: path.split("/").pop() || "",
        onClick: () => this.navigateTo(path),
        onContextMenu: (e) => this.showPinnedItemMenu(e, path),
        draggable: true,
        dragData: { path, index }
      });
    });
    this.setupDragAndDrop(navItems);
  }
  createNavButton(container, options) {
    const btn = container.createEl("button", {
      cls: "nav-item",
      attr: { draggable: options.draggable }
    });
    btn.innerHTML = `
            <svg viewBox="0 0 24 24" class="nav-icon">${options.icon}</svg>
            <span>${options.text}</span>
        `;
    btn.onclick = options.onClick;
    if (options.onContextMenu) {
      btn.oncontextmenu = options.onContextMenu;
    }
    if (options.draggable && options.dragData) {
      this.setupDraggableItem(btn, options.dragData);
    }
    return btn;
  }
  setupDraggableItem(element, dragData) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
      element.classList.add("dragging");
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  setupDragAndDrop(container) {
    let draggedOver = null;
    let dragIndicatorUpdateTimeout;
    let dropTarget = null;
    container.addEventListener("dragover", (e) => {
      e.preventDefault();
      const target = e.target;
      const navItem = target.closest(".nav-item");
      if (navItem && !navItem.classList.contains("dragging")) {
        if (draggedOver !== navItem) {
          draggedOver = navItem;
        }
        clearTimeout(dragIndicatorUpdateTimeout);
        dragIndicatorUpdateTimeout = setTimeout(() => {
          const rect = navItem.getBoundingClientRect();
          const insertAfter = (e.clientX - rect.left) / rect.width > 0.5;
          dropTarget = { element: navItem, insertAfter };
          this.updateDragIndicator(container, navItem, e.clientX);
        }, 10);
      }
    });
    container.addEventListener("dragleave", (e) => {
      const target = e.target;
      const navItem = target.closest(".nav-item");
      if (!navItem || !container.contains(navItem)) {
        this.removeDragIndicator();
        draggedOver = null;
        dropTarget = null;
      }
    });
    container.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      this.removeDragIndicator();
      clearTimeout(dragIndicatorUpdateTimeout);
      if (!dropTarget)
        return;
      try {
        const dragData = JSON.parse(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "");
        const dropIndex = Array.from(container.children).indexOf(dropTarget.element);
        if (typeof dragData.index === "number") {
          const pinnedPaths = this.plugin.getPinnedPaths();
          const [movedPath] = pinnedPaths.splice(dragData.index, 1);
          const newIndex = dropTarget.insertAfter ? dropIndex + 1 : dropIndex;
          pinnedPaths.splice(newIndex, 0, movedPath);
          this.plugin.savePinnedPaths(pinnedPaths);
          this.refreshView();
        }
      } catch (error) {
        console.error("Failed to process drag and drop:", error);
      } finally {
        dropTarget = null;
        draggedOver = null;
      }
    });
  }
  updateDragIndicator(container, target, clientX) {
    this.removeDragIndicator();
    const rect = target.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const indicator = container.createEl("div", { cls: "nav-drag-indicator" });
    const relativeX = (clientX - rect.left) / rect.width;
    if (relativeX > 0.5) {
      indicator.style.left = `${rect.right - containerRect.left}px`;
    } else {
      indicator.style.left = `${rect.left - containerRect.left}px`;
    }
    indicator.style.top = `${rect.top - containerRect.top}px`;
    indicator.style.height = `${rect.height}px`;
  }
  removeDragIndicator() {
    this.containerEl.querySelectorAll(".nav-drag-indicator").forEach((el) => el.remove());
  }
  async navigateTo(path) {
    const target = this.app.vault.getAbstractFileByPath(path);
    if (target instanceof import_obsidian.TFile) {
      const leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf)
        await leaf.openFile(target);
    } else {
      this.state.currentPath = path;
      this.refreshView();
    }
  }
  async openFile(file) {
    this.state.selectedItems.clear();
    const viewType = file.extension === "canvas" ? "canvas" : "markdown";
    const existingLeaf = this.app.workspace.getLeavesOfType(viewType).find((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === viewType) {
        const currentFile = view.file;
        return currentFile && currentFile.path === file.path;
      }
      return false;
    });
    if (existingLeaf) {
      this.app.workspace.setActiveLeaf(existingLeaf, { focus: true });
    } else {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf) {
        if (!activeLeaf.view || activeLeaf.getViewState().type === "empty") {
          await activeLeaf.openFile(file);
        } else {
          const newLeaf = this.app.workspace.getLeaf("tab");
          await newLeaf.openFile(file);
        }
      } else {
        const newLeaf = this.app.workspace.getLeaf(true);
        await newLeaf.openFile(file);
      }
    }
    this.updateSelection();
  }
  toggleFileSelection(file) {
    const path = file.path;
    if (this.state.selectedItems.has(path)) {
      this.state.selectedItems.delete(path);
    } else {
      this.state.selectedItems.add(path);
    }
    this.state.lastSelectedItem = path;
    this.updateSelection();
  }
  selectFileRange(file) {
    const allFiles = this.getAllFiles();
    const currentIndex = allFiles.findIndex((f) => f.path === file.path);
    const lastIndex = allFiles.findIndex((f) => f.path === this.state.lastSelectedItem);
    const [start, end] = [Math.min(currentIndex, lastIndex), Math.max(currentIndex, lastIndex)];
    allFiles.slice(start, end + 1).forEach((f) => {
      this.state.selectedItems.add(f.path);
    });
    this.updateSelection();
  }
  updateSelection() {
    this.containerEl.querySelectorAll(".tree-item.file").forEach((el) => {
      const path = el.getAttribute("data-path");
      if (path) {
        el.classList.toggle("selected", this.state.selectedItems.has(path));
      }
    });
  }
  renderToolbar(container) {
    const toolbar = container.createEl("div", { cls: "tree-toolbar" });
    const searchContainer = toolbar.createEl("div", { cls: "tree-search" });
    const searchInput = searchContainer.createEl("input", {
      cls: "tree-search-input",
      attr: {
        type: "text",
        placeholder: "Search files..."
      }
    });
    searchInput.addEventListener("input", () => {
      this.filterFiles(searchInput.value);
    });
    this.createToolbarButton(toolbar, {
      icon: '<path fill="currentColor" d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>',
      tooltip: "Expand/Collapse All",
      onClick: () => this.toggleAllFolders()
    });
    this.createToolbarButton(toolbar, {
      icon: '<path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>',
      tooltip: "Create New",
      onClick: (e) => this.showCreateMenu(e)
    });
    this.createToolbarButton(toolbar, {
      icon: '<path fill="currentColor" d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"/>',
      tooltip: "Sort",
      onClick: (e) => this.showSortMenu(e)
    });
  }
  toggleAllFolders() {
    const allFolders = Array.from(this.containerEl.querySelectorAll(".folder"));
    const hasCollapsed = allFolders.some((folder) => {
      const path = folder.getAttribute("data-path");
      return path && this.state.collapsedFolders.has(path);
    });
    if (hasCollapsed) {
      this.state.collapsedFolders.clear();
    } else {
      allFolders.forEach((folder) => {
        const path = folder.getAttribute("data-path");
        if (path)
          this.state.collapsedFolders.add(path);
      });
    }
    this.refreshView();
  }
  filterFiles(searchTerm) {
    const treeItems = this.containerEl.querySelectorAll(".tree-item");
    const searchText = searchTerm.toLowerCase().trim();
    if (!searchText) {
      treeItems.forEach((item) => {
        item.style.display = "";
        if (item.classList.contains("folder")) {
          const children = item.querySelector(".folder-children");
          if (children) {
            children.style.display = this.state.collapsedFolders.has(item.getAttribute("data-path") || "") ? "none" : "";
          }
        }
      });
      return;
    }
    treeItems.forEach((item) => {
      var _a, _b, _c;
      let isMatch = false;
      if (item.classList.contains("file")) {
        const fileName = ((_a = item.querySelector(".file-name")) == null ? void 0 : _a.textContent) || "";
        const fileExt = ((_b = item.querySelector(".file-ext")) == null ? void 0 : _b.textContent) || "";
        const fullName = (fileName + fileExt).toLowerCase();
        isMatch = fullName.includes(searchText);
      } else if (item.classList.contains("folder")) {
        const folderName = (((_c = item.querySelector(".folder-title span")) == null ? void 0 : _c.textContent) || "").toLowerCase();
        isMatch = folderName.includes(searchText);
        const children = item.querySelector(".folder-children");
        if (children) {
          const hasMatchingChild = Array.from(children.querySelectorAll(".tree-item")).some((child) => {
            var _a2;
            const childName = (((_a2 = child.querySelector(".file-name, .folder-title span")) == null ? void 0 : _a2.textContent) || "").toLowerCase();
            return childName.includes(searchText);
          });
          if (hasMatchingChild) {
            isMatch = true;
            this.state.collapsedFolders.delete(item.getAttribute("data-path") || "");
            const collapseIcon = item.querySelector(".collapse-icon");
            if (collapseIcon) {
              collapseIcon.classList.remove("collapsed");
            }
            children.style.display = "";
          }
        }
      }
      item.style.display = isMatch ? "" : "none";
    });
  }
  createToolbarButton(container, options) {
    const button = container.createEl("button", {
      cls: "tree-tool-button",
      attr: { "aria-label": options.tooltip }
    });
    button.innerHTML = `<svg viewBox="0 0 24 24" class="nav-icon">${options.icon}</svg>`;
    button.onclick = options.onClick;
    return button;
  }
  showCreateMenu(e) {
    const menu = new import_obsidian.Menu();
    const currentFolder = this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!(currentFolder instanceof import_obsidian.TFolder))
      return;
    menu.addItem((item) => {
      item.setTitle("New Note").setIcon("document").onClick(() => this.createNewFile("md", currentFolder));
    });
    menu.addItem((item) => {
      item.setTitle("New Canvas").setIcon("layout-dashboard").onClick(() => this.createNewFile("canvas", currentFolder));
    });
    menu.addItem((item) => {
      item.setTitle("New Folder").setIcon("folder").onClick(() => this.createNewFolder(currentFolder));
    });
    menu.showAtMouseEvent(e);
  }
  showSortMenu(e) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle("Sort by Name").setIcon(this.state.sortBy === "name" ? "checkmark" : "").onClick(() => {
        this.state.sortBy = "name";
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Sort by Modified").setIcon(this.state.sortBy === "modified" ? "checkmark" : "").onClick(() => {
        this.state.sortBy = "modified";
        this.refreshView();
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Ascending").setIcon(this.state.sortOrder === "asc" ? "checkmark" : "").onClick(() => {
        this.state.sortOrder = "asc";
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Descending").setIcon(this.state.sortOrder === "desc" ? "checkmark" : "").onClick(() => {
        this.state.sortOrder = "desc";
        this.refreshView();
      });
    });
    menu.showAtMouseEvent(e);
  }
  showPinnedItemMenu(e, path) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle("Remove from Navigation").setIcon("trash").onClick(() => {
        this.plugin.removeFromPinnedPaths(path);
        this.refreshView();
      });
    });
    menu.showAtMouseEvent(e);
  }
  async createNewFile(extension, targetFolder) {
    const parent = targetFolder || this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!parent || !(parent instanceof import_obsidian.TFolder))
      return;
    let baseName = "Untitled";
    let counter = 0;
    let fileName = baseName;
    let filePath = "";
    do {
      fileName = counter === 0 ? baseName : `${baseName} ${counter}`;
      filePath = `${parent.path}/${fileName}.${extension}`;
      counter++;
    } while (this.app.vault.getAbstractFileByPath(filePath));
    try {
      const content = extension === "canvas" ? '{"nodes":[],"edges":[]}' : "";
      const file = await this.app.vault.create(filePath, content);
      this.refreshView();
      const leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf) {
        await leaf.openFile(file);
      }
      setTimeout(() => {
        const fileEl = this.containerEl.querySelector(`[data-path="${file.path}"]`);
        if (fileEl) {
          this.startRename(file);
        }
      }, 50);
    } catch (error) {
      console.error(`Failed to create new ${extension} file:`, error);
      new import_obsidian.Notice(`Failed to create new ${extension} file: ${error.message}`);
    }
  }
  async createNewFolder(targetFolder) {
    const parent = targetFolder || this.app.vault.getAbstractFileByPath(this.state.currentPath);
    if (!parent || !(parent instanceof import_obsidian.TFolder))
      return;
    let baseName = "New Folder";
    let counter = 0;
    let folderName = baseName;
    let folderPath = "";
    do {
      folderName = counter === 0 ? baseName : `${baseName} ${counter}`;
      folderPath = `${parent.path}/${folderName}`;
      counter++;
    } while (this.app.vault.getAbstractFileByPath(folderPath));
    try {
      const folder = await this.app.vault.createFolder(folderPath);
      this.refreshView();
      setTimeout(() => {
        const folderEl = this.containerEl.querySelector(`[data-path="${folder.path}"]`);
        if (folderEl) {
          this.startRename(folder);
        }
      }, 50);
    } catch (error) {
      console.error("Failed to create new folder:", error);
      new import_obsidian.Notice(`Failed to create new folder: ${error.message}`);
    }
  }
  getAllFiles() {
    const files = [];
    const processFolder = (folder) => {
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian.TFile) {
          files.push(child);
        } else if (child instanceof import_obsidian.TFolder) {
          processFolder(child);
        }
      });
    };
    processFolder(this.app.vault.getRoot());
    return files;
  }
  renderFileTree(container) {
    const treeContainer = container.createEl("div", { cls: "tree-container" });
    const vault = this.app.vault;
    const root = vault.getRoot();
    const targetFolder = this.state.currentPath === "/" ? root : vault.getAbstractFileByPath(this.state.currentPath);
    if (targetFolder instanceof import_obsidian.TFolder) {
      this.renderFolderContents(treeContainer, targetFolder);
    }
  }
  renderFolderContents(container, folder) {
    const items = folder.children.sort((a, b) => this.sortItems(a, b));
    for (const item of items) {
      if (item instanceof import_obsidian.TFolder) {
        if (!this.shouldHideFolder(item)) {
          this.renderFolderItem(container, item);
        }
      } else if (item instanceof import_obsidian.TFile) {
        this.renderFileItem(container, item);
      }
    }
  }
  shouldHideFolder(folder) {
    return this.plugin.settings.hideAttachments && this.plugin.settings.attachmentFolders.includes(folder.name);
  }
  sortItems(a, b) {
    if (a instanceof import_obsidian.TFolder && !(b instanceof import_obsidian.TFolder))
      return -1;
    if (!(a instanceof import_obsidian.TFolder) && b instanceof import_obsidian.TFolder)
      return 1;
    let comparison = 0;
    if (this.state.sortBy === "name") {
      comparison = a.name.localeCompare(b.name);
    } else {
      const aTime = a instanceof import_obsidian.TFile ? a.stat.mtime : 0;
      const bTime = b instanceof import_obsidian.TFile ? b.stat.mtime : 0;
      comparison = aTime - bTime;
    }
    return this.state.sortOrder === "asc" ? comparison : -comparison;
  }
  renderFileItem(container, file) {
    var _a;
    const fileEl = container.createEl("div", {
      cls: `tree-item file ${((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) === file.path ? "active" : ""} ${this.state.selectedItems.has(file.path) ? "selected" : ""}`,
      attr: {
        "data-path": file.path,
        "draggable": "true"
      }
    });
    const fileTitle = fileEl.createEl("div", { cls: "file-title" });
    const fileIcon = fileTitle.createEl("span", { cls: "file-icon" });
    fileIcon.innerHTML = this.getFileIcon(file);
    fileTitle.createEl("span", {
      cls: "file-name",
      text: file.basename
    });
    fileTitle.createEl("span", {
      cls: "file-ext",
      text: "." + file.extension
    });
    this.setupDraggableFile(fileEl, file);
    fileTitle.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        this.toggleFileSelection(file);
      } else if (e.shiftKey && this.state.lastSelectedItem) {
        this.selectFileRange(file);
      } else {
        if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
          this.state.selectedItems.clear();
        }
        this.state.selectedItems.add(file.path);
        this.state.lastSelectedItem = file.path;
        await this.openFile(file);
      }
      this.updateSelection();
    });
    fileTitle.oncontextmenu = (e) => this.showFileContextMenu(e, file);
  }
  renderFolderItem(container, folder) {
    const folderEl = container.createEl("div", {
      cls: "tree-item folder",
      attr: {
        "data-path": folder.path,
        "draggable": "true"
      }
    });
    const folderHeader = folderEl.createEl("div", { cls: "folder-header" });
    const collapseIcon = folderHeader.createEl("div", {
      cls: `collapse-icon ${this.state.collapsedFolders.has(folder.path) ? "collapsed" : ""}`
    });
    collapseIcon.innerHTML = `<svg viewBox="0 0 24 24" class="nav-icon"><path fill="currentColor" d="M7 10l5 5 5-5H7z"/></svg>`;
    const folderTitle = folderHeader.createEl("div", { cls: "folder-title" });
    const folderIcon = folderTitle.createEl("span", { cls: "folder-icon" });
    folderIcon.innerHTML = `<svg viewBox="0 0 24 24" class="nav-icon"><path fill="currentColor" d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>`;
    folderTitle.createEl("span", { text: folder.name });
    this.setupDraggableFolder(folderEl, folder);
    collapseIcon.onclick = (e) => {
      e.stopPropagation();
      this.toggleFolder(folder);
    };
    folderTitle.onclick = (e) => {
      e.stopPropagation();
      this.toggleFolder(folder);
    };
    folderTitle.oncontextmenu = (e) => this.showFolderContextMenu(e, folder);
    if (!this.state.collapsedFolders.has(folder.path)) {
      const childrenContainer = folderEl.createEl("div", { cls: "folder-children" });
      this.setupDropZone(childrenContainer, folder);
      this.renderFolderContents(childrenContainer, folder);
    }
  }
  setupDraggableFile(element, file) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      e.stopPropagation();
      element.classList.add("dragging");
      const dragData = {
        type: "file",
        paths: this.state.selectedItems.has(file.path) ? Array.from(this.state.selectedItems) : [file.path]
      };
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  setupDraggableFolder(element, folder) {
    element.addEventListener("dragstart", (e) => {
      var _a;
      e.stopPropagation();
      element.classList.add("dragging");
      const dragData = {
        type: "folder",
        path: folder.path
      };
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify(dragData));
    });
    element.addEventListener("dragend", () => {
      element.classList.remove("dragging");
    });
  }
  setupDropZone(element, folder) {
    element.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const draggingEl = this.containerEl.querySelector(".dragging");
      if (!draggingEl)
        return;
      element.classList.add("drop-target");
    });
    element.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      element.classList.remove("drop-target");
    });
    element.addEventListener("drop", async (e) => {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      element.classList.remove("drop-target");
      try {
        const data = JSON.parse(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "");
        if (data.type === "file") {
          const paths = data.paths;
          for (const path of paths) {
            const file = this.app.vault.getAbstractFileByPath(path);
            if (file && file.parent !== folder) {
              const newPath = `${folder.path}/${file.name}`;
              await this.app.vault.rename(file, newPath);
            }
          }
        } else if (data.type === "folder") {
          const sourceFolder = this.app.vault.getAbstractFileByPath(data.path);
          if (sourceFolder && sourceFolder !== folder && !folder.path.startsWith(sourceFolder.path)) {
            const newPath = `${folder.path}/${sourceFolder.name}`;
            await this.app.vault.rename(sourceFolder, newPath);
          }
        }
        this.refreshView();
      } catch (error) {
        console.error("Failed to process drop:", error);
        new import_obsidian.Notice("Failed to move item(s)");
      }
    });
  }
  toggleFolder(folder) {
    if (this.state.collapsedFolders.has(folder.path)) {
      this.state.collapsedFolders.delete(folder.path);
    } else {
      this.state.collapsedFolders.add(folder.path);
    }
    this.refreshView();
  }
  showFileContextMenu(e, file) {
    const menu = new import_obsidian.Menu();
    if (this.state.selectedItems.size > 1) {
      this.showMultipleSelectionMenu(menu);
    } else {
      this.showSingleFileMenu(menu, file);
    }
    menu.showAtMouseEvent(e);
  }
  showMultipleSelectionMenu(menu) {
    const selectedFiles = Array.from(this.state.selectedItems).map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian.TFile);
    menu.addItem((item) => {
      item.setTitle(`Delete ${selectedFiles.length} items`).setIcon("trash").onClick(async () => {
        for (const file of selectedFiles) {
          await this.app.vault.delete(file);
        }
        this.state.selectedItems.clear();
        this.refreshView();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Move to...").setIcon("folder").onClick(() => {
        const folderMenu = new import_obsidian.Menu();
        this.buildFolderSubmenu(folderMenu, this.app.vault.getRoot(), selectedFiles);
        folderMenu.showAtMouseEvent(new MouseEvent("click"));
      });
    });
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(() => {
        for (const file of selectedFiles) {
          this.plugin.addToPinnedPaths(file.path);
        }
        this.refreshView();
      });
    });
  }
  buildFolderSubmenu(menu, folder, files) {
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFolder && !this.shouldHideFolder(child)) {
        menu.addItem((item) => {
          item.setTitle(child.name);
          const hasSubfolders = child.children.some((c) => c instanceof import_obsidian.TFolder);
          if (hasSubfolders) {
            item.setIcon("chevron-right");
          }
          item.onClick((e) => {
            if (hasSubfolders && e instanceof MouseEvent) {
              const subMenu = new import_obsidian.Menu();
              this.buildFolderSubmenu(subMenu, child, files);
              subMenu.showAtPosition({
                x: e.clientX,
                y: e.clientY
              });
            } else {
              this.moveFilesToFolder(files, child);
            }
          });
        });
      }
    }
  }
  async moveFilesToFolder(files, targetFolder) {
    for (const file of files) {
      if (file.parent !== targetFolder) {
        const newPath = `${targetFolder.path}/${file.name}`;
        await this.app.vault.rename(file, newPath);
      }
    }
    this.state.selectedItems.clear();
    this.refreshView();
  }
  showSingleFileMenu(menu, file) {
    menu.addItem((item) => {
      item.setTitle("Open in New Tab").setIcon("lucide-split").onClick(async () => {
        const leaf = this.app.workspace.splitActiveLeaf();
        await leaf.openFile(file);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(() => {
        this.plugin.addToPinnedPaths(file.path);
        this.refreshView();
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Rename").setIcon("pencil").onClick(() => this.startRename(file));
    });
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(async () => {
        await this.app.vault.delete(file);
        this.refreshView();
      });
    });
  }
  showFolderContextMenu(e, folder) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle("New Note").setIcon("document").onClick(() => this.createNewFile("md", folder));
    });
    menu.addItem((item) => {
      item.setTitle("New Canvas").setIcon("layout-dashboard").onClick(() => this.createNewFile("canvas", folder));
    });
    menu.addItem((item) => {
      item.setTitle("New Folder").setIcon("folder").onClick(() => this.createNewFolder(folder));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Pin to Navigation").setIcon("pin").onClick(() => {
        this.plugin.addToPinnedPaths(folder.path);
        this.refreshView();
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Rename").setIcon("pencil").onClick(() => this.startRename(folder));
    });
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(async () => {
        await this.app.vault.delete(folder, true);
        this.refreshView();
      });
    });
    menu.showAtMouseEvent(e);
  }
  getFileIcon(file) {
    const extension = file.extension.toLowerCase();
    switch (extension) {
      case "md":
        return `<svg viewBox="0 0 24 24" class="nav-icon"><path fill="currentColor" d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"/></svg>`;
      case "canvas":
        return `<svg viewBox="0 0 24 24" class="nav-icon"><path fill="currentColor" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/></svg>`;
      default:
        return `<svg viewBox="0 0 24 24" class="nav-icon"><path fill="currentColor" d="M13 9V3.5L18.5 9H13zM6 2c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6H6z"/></svg>`;
    }
  }
  async startRename(item) {
    const itemEl = this.containerEl.querySelector(`[data-path="${item.path}"]`);
    if (!itemEl)
      return;
    const titleEl = itemEl.querySelector(".file-title, .folder-title");
    if (!titleEl)
      return;
    const oldName = item.name;
    const baseName = item instanceof import_obsidian.TFile ? item.basename : oldName;
    titleEl.empty();
    const input = titleEl.createEl("input", {
      cls: "rename-input",
      attr: {
        value: baseName,
        type: "text"
      }
    });
    input.focus();
    input.select();
    const finishRename = async () => {
      var _a, _b;
      const newName = input.value.trim();
      if (newName && newName !== baseName) {
        const extension = item instanceof import_obsidian.TFile ? `.${item.extension}` : "";
        const newPath = `${(_b = (_a = item.parent) == null ? void 0 : _a.path) != null ? _b : ""}/${newName}${extension}`;
        try {
          await this.app.vault.rename(item, newPath);
          if (item instanceof import_obsidian.TFile) {
            const newFile = this.app.vault.getAbstractFileByPath(newPath);
            if (newFile) {
              const leaf = this.app.workspace.getMostRecentLeaf();
              if (leaf) {
                await leaf.openFile(newFile);
              }
            }
          }
        } catch (error) {
          console.error("Failed to rename:", error);
          new import_obsidian.Notice(`Failed to rename: ${error.message}`);
        }
      }
      this.refreshView();
    };
    input.onblur = finishRename;
    input.onkeydown = async (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        await finishRename();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.refreshView();
      }
    };
  }
  updateFileState(file) {
    const fileEl = this.containerEl.querySelector(`[data-path="${file.path}"]`);
    if (fileEl) {
      const titleEl = fileEl.querySelector(".file-title");
      if (titleEl) {
        const nameEl = titleEl.querySelector(".file-name");
        const extEl = titleEl.querySelector(".file-ext");
        if (nameEl && extEl) {
          nameEl.textContent = file.basename;
          extEl.textContent = "." + file.extension;
        }
      }
    }
  }
  updateActiveState() {
    const activeFile = this.app.workspace.getActiveFile();
    this.containerEl.querySelectorAll(".tree-item.file").forEach((el) => {
      const path = el.getAttribute("data-path");
      if (path) {
        el.classList.toggle("active", (activeFile == null ? void 0 : activeFile.path) === path);
      }
    });
  }
};

// settings.ts
var DEFAULT_SETTINGS = {
  hideAttachments: false,
  openOnStartup: false,
  attachmentFolders: [],
  showRootNav: true,
  pinnedPaths: []
};

// settings-tab.ts
var import_obsidian2 = require("obsidian");
var NavigableFileTreeSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Hide attachments folders").setDesc("Hide folders that typically contain attachments").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideAttachments).onChange(async (value) => {
      var _a;
      this.plugin.settings.hideAttachments = value;
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Open on startup").setDesc("Automatically open the file tree when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.openOnStartup).onChange(async (value) => {
      this.plugin.settings.openOnStartup = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian2.Setting(containerEl).setName("Attachment folders").setDesc('Folders to hide when "Hide attachments folders" is enabled (one per line)').addTextArea((text) => text.setValue(this.plugin.settings.attachmentFolders.join("\n")).onChange(async (value) => {
      var _a;
      this.plugin.settings.attachmentFolders = value.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Root navigation").setDesc("Show Root button in navigation bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRootNav).onChange(async (value) => {
      var _a;
      this.plugin.settings.showRootNav = value;
      await this.plugin.saveData(this.plugin.settings);
      (_a = this.plugin.view) == null ? void 0 : _a.refreshView();
    }));
  }
};

// main.ts
var NavigableFileTreePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.pinnedPaths = [];
  }
  async onload() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.registerView("navigable-file-tree", (leaf) => this.view = new FileTreeView(leaf, this));
    const ribbonIconEl = this.addRibbonIcon("list-tree", "File Tree", () => {
      this.activateView();
    });
    ribbonIconEl.draggable = true;
    ribbonIconEl.addEventListener("dragstart", (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.setData("text/plain", "navigable-file-tree");
        e.dataTransfer.effectAllowed = "move";
      }
    });
    this.addSettingTab(new NavigableFileTreeSettingTab(this.app, this));
    if (this.settings.openOnStartup) {
      this.activateView();
    }
    this.loadData().then((data) => {
      var _a;
      this.pinnedPaths = (data == null ? void 0 : data.pinnedPaths) || [];
      (_a = this.view) == null ? void 0 : _a.refreshView();
    });
  }
  async onunload() {
    await this.saveData({ pinnedPaths: this.pinnedPaths });
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType("navigable-file-tree");
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeftLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: "navigable-file-tree",
          active: true
        });
        this.app.workspace.revealLeaf(leaf);
      }
    } else {
      leaves.forEach((leaf) => leaf.detach());
    }
  }
  addToPinnedPaths(path) {
    var _a;
    if (!this.pinnedPaths.includes(path)) {
      this.pinnedPaths.push(path);
      (_a = this.view) == null ? void 0 : _a.refreshView();
    }
  }
  removeFromPinnedPaths(path) {
    var _a;
    this.pinnedPaths = this.pinnedPaths.filter((p) => p !== path);
    (_a = this.view) == null ? void 0 : _a.refreshView();
  }
  getPinnedPaths() {
    return this.pinnedPaths;
  }
  savePinnedPaths(paths) {
    this.settings.pinnedPaths = paths;
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
